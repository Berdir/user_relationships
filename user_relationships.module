<?php
// $Id$

/**
 *
 * This file contains utility functions for the User Relationships module
 * Please consult either the other files for public functions
 *
 */

// Load all needed files
foreach (array(
  'api', 'theme', 'hooks', 'pages', 'forms', 'actions'
  ) as $file_to_include
) { 
  $modulepath = drupal_get_path('module', 'user_relationships');
  include_once("{$modulepath}/user_relationships_{$file_to_include}.inc");
}


/**
 * Returns a nested array of default messages
 */
function user_relationships_default_messages() {
  return array(
    'informational' => array(
      'submitted'     => 'Your request to be a %relationship_name of !requestee has been submitted.',
      'accepted'      => 'You are now a %relationship_name of !requestee.',
      'denied'        => "!requester's request to be a %relationship_name of !requestee has been removed.",
      'default'       => 'No action has been taken.',
      'removed'       => '!requester is no longer a %relationship_name of !requestee.',
      'pending'       => '!requester believes they are a %relationship_name of yours.  Please view your !pending_relationship_requests to approve them.',
      'pre_approved'  => "You're request to be %relationship_name of !requestee has been automatically approved. You are now a %relationship_name of !requestee."
    ),
    'error' => array(
      'too_many_relationships'  => 'You already relate to this user in every possible way.',
      'existing_request'        => 'You have already requested to be a %relationship_name of !requestee',
      'existing_relationship'   => 'You are already a %relationship_name of !requestee',
      'not_accepting_requests'  => 'This user is not accepting relationship requests.',
      'self_request'            => 'You are not allowed to create a relationship to yourself.',
      'non_existant_user'       => 'This user does not exist.',
    ),
  );
}


/**
 * Recursively search an array for a key and return the value attached to it
 */
function _user_relationships_get_from_array($needle, &$haystack) {
  foreach ($haystack as $key => $value) {
    if ($key == $needle) {
      return $value;
    }
    else if (is_array($value)) {
      if ($msg = _user_relationships_get_from_array($needle, $value)) {
        return $msg;
      }
    }
  }
}


/**
 * Invoke hook_user_relationships()
 */
function _user_relationships_invoke($type, &$relationship, $category = NULL) {
  foreach (module_list() as $module) {
    $function = $module .'_user_relationships';
    if (function_exists($function)) {
      $function($type, $relationship, $category);
    }
  }
}

/**
 * Adds autocompletion capability
 */
function _user_relationships_autocomplete_types($string = '') {
  $matches = array();
  if ($string) {
    $result = db_query_range("SELECT name FROM {user_relationship_types} WHERE LOWER(name) LIKE LOWER('%%%s%%')", $string, 0, 10);
    while ($relationship = db_fetch_object($result)) {
      $matches[$relationship->name] = check_plain($relationship->name);
   }
  }
  print drupal_to_js($matches);
  exit();
}

/*
 * Notify the user of pending relationship requests
 */
function _user_relationships_set_notifications(&$account) {
  global $user;

  //only do this for the active user
  if ($account->uid != $user->uid) {
    return;
  }

  $notifications = drupal_get_messages('status', FALSE);
  $notifications = $notifications['status'] ? $notifications['status'] : array();

  $relationships = user_relationships_load(array('requestee_id' => $account->uid, 'approved' => FALSE));
  foreach ($relationships as $relationship) {
    $msg = user_relationships_get_message('pending', $relationship, array(
      '!pending_relationship_requests'  => l(t('pending relationship requests'), 'relationships/'. $account->uid .'/requests')
    ));

    if (!in_array($msg, $notifications)) {
      drupal_set_message($msg);
    }
  }
}


/**
 * List of relationships between two users
 */
function _user_relationships_between(&$viewer, &$viewed) {
  $list = array();

  $relationships = user_relationships_load(array('requester_id' => $viewer->uid, 'requestee_id' => $viewed->uid));
  foreach ($relationships as $relationship) {
    if ($relationship->approved && !$list[$relationship->rid]) {
      $list[$relationship->rid] = t('%relationship_name (!remove_link)', array(
        '%relationship_name'  => $relationship->name,
        '!remove_link'        => theme('user_relationships_remove_link', $viewer->uid, $relationship)
      ));
    }
  }

  return $list;
}


/**
 * List of pending relationships with between two users
 */
function _user_relationships_actions_between(&$viewer, &$viewed) {
  if ($viewer->uid == $viewed->uid) {
    return;
  }

  $list = array();

  $relationships = user_relationships_load(array('requester_id' => $viewer->uid, 'approved' => FALSE));
  foreach ($relationships as $relationship) {
    $list[] = t('You have requested to be a %relationship_name of this user. (!pending_requests)', array(
      '%relationship_name'  => $relationship->name,
      '!pending_requests'   => l(t('pending requests'), "relationships/{$viewer->uid}/requests"),
    ));
  }

  $relationships = user_relationships_load(array('requester_id' => $viewed->uid, 'approved' => FALSE));
  foreach ($relationships as $relationship) {
    $list[] = t('This user believes that they are a %relationship_name of yours. (!pending_requests)', array(
      '%relationship_name'  => $relationship->name,
      '!pending_requests'   => l(t('pending requests'), "relationships/{$viewer->uid}/requests"),
    ));
  }

  if (
    variable_get('user_relationships_allow_multiple', TRUE) && 
    (user_relationships_load(array('requester_id' => $viewer->uid, 'requestee_id' => $viewed->uid), TRUE) < (int)db_result(db_query("SELECT COUNT(*) FROM {user_relationship_types}")))
  ) {
    $list[] = theme('user_relationships_request_relationship_link', $viewed);
  }

  return $list;
}


/**
 * Helper function to build the settings form for the notification messages
 */
function _user_relationships_message_settings_form(&$form, $defaults = array()) {
  foreach ($defaults as $key => $value) {
    if (is_array($value)) {
      $form[$key] = array(
        '#type'         => 'fieldset',
        '#title'        => ucfirst(str_replace('_',' ',$key)),
        '#collapsible'  => TRUE,
        '#collapsed'    => TRUE
      );
      _user_relationships_message_settings_form($form[$key], $value);
    }
    else {
      $form["user_relationships_msg_{$key}"] = array(
        '#type'           => 'textfield',
        '#title'          => ucfirst(str_replace('_',' ',$key)),
        '#default_value'  => variable_get("user_relationships_msg_{$key}", $value)
      );
    }
  }  
}


/**
 * Create the new relationship
 */
function _user_relationships_save_relationship(&$relationship, $op = 'create') {
  _user_relationships_invoke('pre-save', $relationship, $op);

  $relationship->created_at = $relationship->created_at ? $relationship->created_at : time();

  if ($relationship->rid) {
    db_query("DELETE FROM {user_relationships} WHERE rid = %d", $relationship->rid);
  }
  else {
    $relationship->rid = db_next_id('{user_relationships}_id');
  }

  $relationship_type = user_relationships_type_load($relationship->rtid);
  $query = "INSERT INTO {user_relationships} (rid, requester_id, requestee_id, rtid, approved, created_at, updated_at) VALUES";
  $insertions = "(%d, %d, %d, %d, %d, %d, %d)";
  $arguments = array(
    $relationship->rid,
    $relationship->requester_id,
    $relationship->requestee_id,
    $relationship->rtid,
    $relationship->approved,
    $relationship->created_at,
    time(),
  );
  if ($relationship->approved && !$relationship_type->is_oneway) {
    $insertions .= ", {$insertions}";
    $arguments = array_merge($arguments, $arguments);
    $requester = $arguments[8];
    $arguments[8] = $arguments[9];
    $arguments[9] = $requester;
  }

  db_query("{$query} {$insertions}", $arguments);

  _user_relationships_invoke('post-save', $relationship, $op);

  return $relationship;
}


/**
 * Helper function to generate queries from a list of parameters
 */
function _user_relationships_generate_query($param = array(), $order = NULL, $limit = NULL) {
  // Turn the conditions into a query.
  $group = FALSE;
  foreach ($param as $key => $value) {
    if (!isset($value)) { continue; }

    switch ($key) {
    case 'between':
      $cond[] = 
        '(ur.requester_id = %d AND ur.requestee_id = %d)'.
        ' OR '.
        '(urt.is_oneway = 1 AND ur.requestee_id = %d AND ur.requester_id = %d)';
      $arguments[] = (int)$value[0];
      $arguments[] = (int)$value[1];
      $arguments[] = (int)$value[0];
      $arguments[] = (int)$value[1];
      break;

    case 'user':
      $group = TRUE;
      $cond[] = '(ur.requester_id = %d OR ur.requestee_id = %d)';
      $arguments[] = (int)$value[0];
      $arguments[] = (int)$value[0];
      break;

    default:
      $cond[] = 'ur.'. db_escape_string($key) ." = %d";
      $arguments[] = $value === FALSE ? 0 : ($value === TRUE ? 1 : (int)$value);
    }
  }

  $cond = implode(' AND ', $cond);
  if ($group) { $cond .= ' GROUP BY ur.rid'; }
  if (!empty($order)) { $cond .= " ORDER BY {$order}"; }
  if (!empty($limit)) { $cond .= " LIMIT {$limit}"; }
  return array(
    'query'     => 
      "SELECT ur.rid, ur.*, urt.*, 
         requesters.name AS requester_name, 
         requestees.name AS requestee_name,
         requesters.mail AS requester_mail, 
         requestees.mail AS requestee_mail,
         requesters.data AS requester_data, 
         requestees.data AS requestee_data
       FROM {user_relationships} ur 
        INNER JOIN {user_relationship_types} urt ON ur.rtid = urt.rtid 
        LEFT JOIN {users} requesters ON ur.requester_id = requesters.uid
        LEFT JOIN {users} requestees ON ur.requestee_id = requestees.uid
      WHERE {$cond}",
    'count'     => "SELECT COUNT(rid) FROM {user_relationships} ur WHERE {$cond}",
    'arguments' => $arguments,
  );
}
